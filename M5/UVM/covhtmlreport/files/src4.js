var g_data = {"name":"classes/sequence.sv","src":"class fifo_burst_wr_seq extends uvm_sequence #(fifo_transaction);\n  `uvm_object_utils(fifo_burst_wr_seq) // Register the class with the factory\n\n  // Declare handle to the transaction packet\n  fifo_transaction tx_wr;\n  \n  // Counter for the current burst number\n  int burst_count = 1;    \n  \n  // Constructor \n  function new(string name=\"fifo_burst_wr_seq\");\n    super.new(name);\n  endfunction\n  \n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    // TODO: Can this created once per burst? \n    tx_wr = fifo_transaction::type_id::create(\"tx_wr\");\n    repeat(BURST_TX_CNT) begin\n      `uvm_info(\"BURST_WRITE_SEQ\", $sformatf(\"Starting burst write sequence number: %0d\", burst_count), UVM_MEDIUM)\n      repeat (BURST_SIZE) begin\n        start_item(tx_wr);\n        \n        // Burst of writes with random data\n        assert(tx_wr.randomize() with {op == WRITE;});\n        tx_wr.wr_en = 1;\n        \n        `uvm_info(\"GENERATE\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n      // 72 No-write tx to allow FIFO to be emptied -> 72*12.5 = 900 ticks (Delta btw read and write bursts)\n      // Plus 8 dummy txs per buffer count (8 Write Clks = 5 Read Clks)\n      repeat (72+(8*BUFFER_CNT)) begin\n        start_item(tx_wr);\n        tx_wr.wr_en = 0;\n        `uvm_info(\"GENERATE\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n      burst_count++;\n    end\n\n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\n  \nendclass\n\nclass fifo_burst_rd_seq extends uvm_sequence #(fifo_transaction);\n  `uvm_object_utils(fifo_burst_rd_seq) // Register the class with the factory\n\n  // Declare handles to the transaction packet\n  fifo_transaction tx_rd;\n  \n  // Counter for the current burst number\n  int burst_count = 1;    \n  \n  // Constructor \n  function new(string name=\"fifo_burst_rd_seq\");\n    super.new(name);\n  endfunction\n  \n  // virtual task body();\n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    // TODO: Can this created once per burst? \n    tx_rd = fifo_transaction::type_id::create(\"tx_rd\");\n    repeat(BURST_TX_CNT) begin\n      `uvm_info(\"BURST_READ_SEQ\", $sformatf(\"Starting burst read sequence number: %0d\", burst_count), UVM_MEDIUM)\n      repeat (BURST_SIZE) begin\n        start_item(tx_rd);\n        \n        // Burst of writes with random data\n        tx_rd.op = READ; \n        tx_rd.rd_en = 1;\n        \n        `uvm_info(\"GENERATE\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n      // 5 dummy txs per buffer count (5 Read Clks = 8 Write Clks)\n      repeat(5*BUFFER_CNT) begin\n        start_item(tx_rd);\n        tx_rd.rd_en = 0;\n        `uvm_info(\"GENERATE\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n      burst_count++;\n    end\n   \n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\nendclass\n\nclass fifo_flag_wr_seq extends fifo_burst_wr_seq;\n  `uvm_object_utils(fifo_flag_wr_seq) // Register the class with the factory\n\n  // Declare handle to the transaction packet\n  fifo_transaction tx_wr;\n  \n  // Constructor \n  function new(string name=\"fifo_flag_wr_seq\");\n    super.new(name);\n  endfunction\n  \n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    `uvm_info(\"FLAG_WRITE_SEQ\", \"Starting write sequence for flag_test\", UVM_MEDIUM)\n    \n    tx_wr = fifo_transaction::type_id::create(\"tx_wr\");\n    repeat(32) begin // 32 writes to half-fill the FIFO\n      start_item(tx_wr);\n      \n      assert(tx_wr.randomize() with {op == WRITE;});\n      tx_wr.wr_en = 1;\n      \n      `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n      finish_item(tx_wr);\n    end\n\n    // 8 Writes = 5 Reads => Toggle write tx signals in sets of 8\n    // FLAG_TX_CNT controls the number of times the HALF flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial 32 writes\n    repeat (FLAG_TX_CNT-1) begin\n      repeat (7) begin\n        start_item(tx_wr);\n        tx_wr.wr_en = 0;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n      repeat (1) begin\n        start_item(tx_wr);\n        assert(tx_wr.randomize() with {op == WRITE;});\n        tx_wr.wr_en = 1;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n    end\n\n    // 32 more writes to fill the FIFO\n    repeat(32) begin \n      start_item(tx_wr);\n      assert(tx_wr.randomize() with {op == WRITE;});\n      tx_wr.wr_en = 1;\n      `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n      finish_item(tx_wr);\n    end\n\n    // 8 Writes = 5 Reads => Toggle write tx signals in sets of 8\n    // FLAG_TX_CNT controls the number of times the FULL flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial 64 writes\n    repeat (FLAG_TX_CNT-1) begin\n      repeat (7) begin\n        start_item(tx_wr);\n        tx_wr.wr_en = 0;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n      repeat (1) begin\n        start_item(tx_wr);\n        assert(tx_wr.randomize() with {op == WRITE;});\n        tx_wr.wr_en = 1;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n    end\n    // 104 write clks = 64+1 read clks to empty the FIFO\n    repeat (104) begin\n      start_item(tx_wr);\n        tx_wr.wr_en = 0;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n    \n    // 8 Writes = 5 Reads => Toggle write tx signals in sets of 8\n    // FLAG_TX_CNT controls the number of times the EMPTY flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial read to empty \n    repeat (FLAG_TX_CNT-1) begin\n      repeat (1) begin\n        start_item(tx_wr);\n        assert(tx_wr.randomize() with {op == WRITE;});\n        tx_wr.wr_en = 1;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n      repeat (7) begin\n        start_item(tx_wr);\n        tx_wr.wr_en = 0;\n        `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n        finish_item(tx_wr);\n      end\n    end\n\n    // 8 dummy transactions to buffer between tests\n    repeat(8) begin\n      start_item(tx_wr);\n      tx_wr.wr_en = 0;\n      `uvm_info(\"GENERATE\", tx_wr.convert2string(), UVM_HIGH)\n      finish_item(tx_wr);\n    end\n\n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\n  \nendclass\nclass fifo_flag_rd_seq extends fifo_burst_rd_seq;\n  `uvm_object_utils(fifo_flag_rd_seq) // Register the class with the factory\n\n  // Declare handles to the transaction packet\n  fifo_transaction tx_rd;\n  \n  // Constructor \n  function new(string name=\"fifo_flag_rd_seq\");\n    super.new(name);\n  endfunction\n  \n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    `uvm_info(\"FLAG_READ_SEQ\", \"Starting read sequence for flag_test\", UVM_MEDIUM)\n    tx_rd = fifo_transaction::type_id::create(\"tx_rd\");\n    repeat(20) begin // 20 tx w/o rd_en to half-fill the FIFO -> 20 Read Clks = 32 Write Clks\n      start_item(tx_rd);\n      tx_rd.op = READ;\n      tx_rd.rd_en = 0;\n      `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n      finish_item(tx_rd);\n    end\n\n    // 5 Reads = 8 Writes => Toggle read tx signals in sets of 5\n    // FLAG_TX_CNT controls the number of times the HALF flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial half-fill\n    repeat (FLAG_TX_CNT-1) begin\n      repeat (1) begin\n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 1;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n      repeat (4) begin \n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 0;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n    end\n\n    repeat(20) begin // 20 tx w/o rd_en to fill the FIFO -> 20 Read Clks = 32 Write Clks\n      start_item(tx_rd);\n      tx_rd.op = READ;\n      tx_rd.rd_en = 0;\n      `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n      finish_item(tx_rd);\n    end\n\n    // 5 Reads = 8 Writes => Toggle read tx signals in sets of 5\n    // FLAG_TX_CNT controls the number of times the FULL flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial fill\n    repeat (FLAG_TX_CNT-1) begin\n      repeat (1) begin\n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 1;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n      repeat (4) begin \n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 0;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n    end \n\n    // 64 Reads to empty the FIFO\n    repeat (64) begin\n      start_item(tx_rd);\n      tx_rd.op = READ;\n      tx_rd.rd_en = 1;\n      `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n      finish_item(tx_rd);\n    end \n    // Single read to make 65 => 65 Read Clks = 104 Write Clks\n    start_item(tx_rd);\n    tx_rd.op = READ;\n    tx_rd.rd_en = 0;\n    `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n    finish_item(tx_rd);\n\n    // 5 Reads = 8 Writes => Toggle read tx signals in sets of 5\n    // FLAG_TX_CNT controls the number of times the EMPTY flag is toggled\n    // One less then FLAG_TX_CNT to allow for the initial emptying\n    repeat (FLAG_TX_CNT-1) begin\n      repeat (4) begin\n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 0;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n      repeat (1) begin \n        start_item(tx_rd);\n        tx_rd.op = READ;\n        tx_rd.rd_en = 1;\n        `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n        finish_item(tx_rd);\n      end\n    end\n\n    // 5 dummy transactions to buffer between tests \n    repeat(5) begin\n      start_item(tx_rd);\n      tx_rd.wr_en = 0;\n      tx_rd.rd_en = 0;\n      `uvm_info(\"GENERATE\", tx_rd.convert2string(), UVM_HIGH)\n      finish_item(tx_rd);\n    end\n    \n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\n\nendclass\n\nclass fifo_random_wr_seq extends fifo_burst_wr_seq;\n  `uvm_object_utils(fifo_random_wr_seq) // Register the class with the factory\n\n  // Declare handles to the transaction packet\n  fifo_transaction tx_wr;\n  \n  // Constructor \n  function new(string name=\"fifo_random_wr_seq\");\n    super.new(name);\n  endfunction\n  \n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    `uvm_info(\"RANDOM_WRITE_SEQ\", \"Starting write sequence for random_test\", UVM_MEDIUM)\n    \n    // Force one write so there is data if first randomzied read tx has rd_en asserted\n    tx_wr = fifo_transaction::type_id::create(\"tx_wr\");\n    repeat(1) begin \n      start_item(tx_wr);\n      \n      assert(tx_wr.randomize() with {op == WRITE;});\n      tx_wr.wr_en = 1;\n      \n      `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n      finish_item(tx_wr);\n    end \n    // Remaining writes are fully randomzied\n    repeat(RANDOM_TX_CNT-1) begin \n      start_item(tx_wr);\n      \n      assert(tx_wr.randomize() with {op == WRITE;});\n      `uvm_info(\"GENERATED\", tx_wr.convert2string(), UVM_HIGH)\n      \n      finish_item(tx_wr);\n    end\n\n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\n  \nendclass\nclass fifo_random_rd_seq extends fifo_burst_rd_seq;\n  `uvm_object_utils(fifo_random_rd_seq) // Register the class with the factory\n\n  // Declare handles to the transaction packet\n  fifo_transaction tx_rd;\n  \n  // Constructor \n  function new(string name=\"fifo_random_rd_seq\");\n    super.new(name);\n  endfunction\n  \n  // Not virtual in Doulos Video\n  task body();\n    if (starting_phase != null)\n      starting_phase.raise_objection(this);\n\n    `uvm_info(\"RANDOM_READ_SEQ\", \"Starting read sequence for random_test\", UVM_MEDIUM)\n    \n    // Fully randomzied read transactions \n    tx_rd = fifo_transaction::type_id::create(\"tx_rd\");\n    repeat(RANDOM_TX_CNT) begin \n      start_item(tx_rd);\n      \n      assert(tx_rd.randomize() with {op == READ;});\n      \n      `uvm_info(\"GENERATED\", tx_rd.convert2string(), UVM_HIGH)\n      finish_item(tx_rd);\n    end\n    if (starting_phase != null)\n      starting_phase.drop_objection(this);\n  endtask : body\n\nendclass\n","lang":"verilog"};
processSrcData(g_data);